name: Handle degraded rule result

on:
  workflow_dispatch:
    inputs:
      rule_result_id:
        description: "The rule result entity identifier"
        required: true
        type: string
      rule_id:
        description: "The rule entity identifier"
        required: true
        type: string
      entity_id:
        description: "The entity identifier that failed the rule"
        required: true
        type: string
      run_id:
        description: "Port action run ID"
        required: true
        type: string

jobs:
  print_inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Log message to Port run
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: "Starting scorecard failure handling for rule result: ${{ inputs.rule_result_id }}"
      
      - name: Get rule entity information
        id: get_rule
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: GET
          blueprint: "_rule"
          identifier: ${{ inputs.rule_id }}
      
      - name: Get entity information
        id: get_entity
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: GET
          blueprint: s3
          identifier: ${{ inputs.entity_id }}
      
      - name: Extract rule properties and validate
        id: extract_rule
        run: |
          # The Port GitHub Action outputs the entity as a JSON string with potential newlines
          # Use Python to repair and parse the JSON
          python3 << 'PYEOF'
          import json
          import os
          import sys
          import re
          
          # Get the raw JSON string from GitHub Actions output
          entity_json_raw = '''${{ steps.get_rule.outputs.entity }}'''
          
          if not entity_json_raw or entity_json_raw.strip() == "null":
              print("Error: Rule entity not found or empty", file=sys.stderr)
              sys.exit(1)
          
          # Repair JSON by escaping newlines and other control characters in string values
          # This regex finds string values (including nested ones) and escapes control chars
          def escape_control_chars(match):
              # Get the full match including quotes
              full_match = match.group(0)
              # Get the content between quotes
              content = match.group(1)
              # Escape control characters
              content = (content
                        .replace('\\', '\\\\')  # Escape backslashes first
                        .replace('\n', '\\n')
                        .replace('\r', '\\r')
                        .replace('\t', '\\t')
                        .replace('\b', '\\b')
                        .replace('\f', '\\f'))
              return f'"{content}"'
          
          # Pattern to match string values: "..." but not already escaped ones
          # This is tricky - we need to match strings but handle escaped quotes
          # Simple approach: replace newlines in the raw string before JSON parsing
          # But we need to be careful not to break the JSON structure
          
          # Better approach: use a state machine or use json.JSONDecoder with custom handling
          # For now, let's try a simpler fix: replace literal newlines that are inside string values
          # We'll use a more targeted approach
          
          print("Step: Extract rule properties - Starting JSON parsing", file=sys.stderr)
          print(f"Raw JSON length: {len(entity_json_raw)} characters", file=sys.stderr)
          print(f"Raw JSON preview (first 200 chars): {entity_json_raw[:200]}", file=sys.stderr)
          
          try:
              # First, try to parse as-is
              print("Attempting initial JSON parse...", file=sys.stderr)
              entity = json.loads(entity_json_raw)
              print("✓ Initial JSON parse succeeded", file=sys.stderr)
          except json.JSONDecodeError as initial_error:
              print(f"✗ Initial JSON parse failed: {initial_error}", file=sys.stderr)
              print(f"Error at position: {initial_error.pos if hasattr(initial_error, 'pos') else 'unknown'}", file=sys.stderr)
              print("Attempting JSON repair (escaping control characters)...", file=sys.stderr)
              
              # More robust: iterate through and fix string values
              result = []
              i = 0
              in_string = False
              escape_next = False
              chars_fixed = 0
              
              while i < len(entity_json_raw):
                  char = entity_json_raw[i]
                  
                  if escape_next:
                      result.append(char)
                      escape_next = False
                  elif char == '\\':
                      result.append(char)
                      escape_next = True
                  elif char == '"' and not escape_next:
                      in_string = not in_string
                      result.append(char)
                  elif in_string and char == '\n':
                      result.append('\\n')
                      chars_fixed += 1
                  elif in_string and char == '\r':
                      result.append('\\r')
                      chars_fixed += 1
                  elif in_string and char == '\t':
                      result.append('\\t')
                      chars_fixed += 1
                  else:
                      result.append(char)
                  
                  i += 1
              
              fixed_json = ''.join(result)
              print(f"JSON repair complete: fixed {chars_fixed} control characters", file=sys.stderr)
              print(f"Fixed JSON preview (first 200 chars): {fixed_json[:200]}", file=sys.stderr)
              
              try:
                  entity = json.loads(fixed_json)
                  print("✓ JSON parse succeeded after repair", file=sys.stderr)
              except json.JSONDecodeError as repair_error:
                  print(f"✗ JSON parse failed after repair: {repair_error}", file=sys.stderr)
                  print(f"Error at position: {repair_error.pos if hasattr(repair_error, 'pos') else 'unknown'}", file=sys.stderr)
                  print(f"Error message: {repair_error.msg}", file=sys.stderr)
                  print(f"Raw JSON (first 1000 chars): {entity_json_raw[:1000]}", file=sys.stderr)
                  print(f"Fixed JSON (first 1000 chars): {fixed_json[:1000]}", file=sys.stderr)
                  sys.exit(1)
          
          # Extract properties
          print("Extracting properties from parsed entity...", file=sys.stderr)
          properties = entity.get('properties', {})
          rule_description = properties.get('description', '')
          rule_template = properties.get('template', '')
          rule_team = entity.get('team', '')
          rule_title = entity.get('title') or entity.get('identifier', '')
          rule_identifier = entity.get('identifier', '')
          
          print(f"Extracted values:", file=sys.stderr)
          print(f"  - rule_identifier: {rule_identifier}", file=sys.stderr)
          print(f"  - rule_title: {rule_title}", file=sys.stderr)
          print(f"  - rule_description length: {len(rule_description)} chars", file=sys.stderr)
          print(f"  - rule_template length: {len(rule_template)} chars", file=sys.stderr)
          print(f"  - rule_team: {rule_team}", file=sys.stderr)
          
          # Validate that description and template are not null/empty
          validation_failed = False
          error_message = ""
          
          if not rule_description or rule_description == "null":
              validation_failed = True
              error_message = f"Rule description is missing or null for rule: {rule_identifier}"
              print(f"✗ Validation failed: {error_message}", file=sys.stderr)
          elif not rule_template or rule_template == "null":
              validation_failed = True
              error_message = f"Rule template is missing or null for rule: {rule_identifier}"
              print(f"✗ Validation failed: {error_message}", file=sys.stderr)
          else:
              print("✓ Validation passed: description and template are present", file=sys.stderr)
          
          # Set GitHub Actions outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"VALIDATION_FAILED={str(validation_failed).lower()}\n")
              if validation_failed:
                  f.write(f"ERROR_MESSAGE={error_message}\n")
              else:
                  # Use multiline format for values that might contain newlines
                  if '\n' in rule_description:
                      f.write(f"description<<EOF\n{rule_description}\nEOF\n")
                  else:
                      f.write(f"description={rule_description}\n")
                  
                  if '\n' in rule_template:
                      f.write(f"template<<EOF\n{rule_template}\nEOF\n")
                  else:
                      f.write(f"template={rule_template}\n")
                  
                  f.write(f"team={rule_team}\n")
                  f.write(f"title={rule_title}\n")
                  f.write(f"identifier={rule_identifier}\n")
          
          if not validation_failed:
              print(f"Rule Description: {rule_description}")
              print(f"Rule Template: {rule_template}")
              print(f"Rule Team: {rule_team}")
          
          sys.exit(0)
          PYEOF
      
      - name: Log validation error and exit
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'true'
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: ${{ steps.extract_rule.outputs.ERROR_MESSAGE }}
      
      - name: Fail if validation failed
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'true'
        run: |
          echo "Validation failed. Exiting workflow."
          exit 1
      
      - name: Generate template content
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: generate_template
        run: |
          # Use Python to parse entity JSON and generate template content
          python3 << 'PYEOF'
          import json
          import os
          import sys
          import re
          
          # Get the raw JSON strings from GitHub Actions outputs
          entity_json_raw = '''${{ steps.get_entity.outputs.entity }}'''
          rule_title = '''${{ steps.extract_rule.outputs.title }}'''
          rule_identifier = '''${{ steps.extract_rule.outputs.identifier }}'''
          rule_description = '''${{ steps.extract_rule.outputs.description }}'''
          rule_template = '''${{ steps.extract_rule.outputs.template }}'''
          
          # Parse entity JSON (same repair logic as rule extraction)
          def repair_json(json_str):
              result = []
              i = 0
              in_string = False
              escape_next = False
              
              while i < len(json_str):
                  char = json_str[i]
                  
                  if escape_next:
                      result.append(char)
                      escape_next = False
                  elif char == '\\':
                      result.append(char)
                      escape_next = True
                  elif char == '"' and not escape_next:
                      in_string = not in_string
                      result.append(char)
                  elif in_string and char == '\n':
                      result.append('\\n')
                  elif in_string and char == '\r':
                      result.append('\\r')
                  elif in_string and char == '\t':
                      result.append('\\t')
                  else:
                      result.append(char)
                  
                  i += 1
              
              return ''.join(result)
          
          # Parse entity JSON
          print("Step: Generate template - Starting entity JSON parsing", file=sys.stderr)
          print(f"Entity JSON length: {len(entity_json_raw)} characters", file=sys.stderr)
          print(f"Entity JSON preview (first 200 chars): {entity_json_raw[:200]}", file=sys.stderr)
          
          try:
              print("Attempting initial entity JSON parse...", file=sys.stderr)
              entity = json.loads(entity_json_raw)
              print("✓ Initial entity JSON parse succeeded", file=sys.stderr)
          except json.JSONDecodeError as initial_error:
              print(f"✗ Initial entity JSON parse failed: {initial_error}", file=sys.stderr)
              print(f"Error at position: {initial_error.pos if hasattr(initial_error, 'pos') else 'unknown'}", file=sys.stderr)
              print("Attempting entity JSON repair...", file=sys.stderr)
              fixed_json = repair_json(entity_json_raw)
              print(f"Entity JSON repair complete. Fixed JSON preview (first 200 chars): {fixed_json[:200]}", file=sys.stderr)
              try:
                  entity = json.loads(fixed_json)
                  print("✓ Entity JSON parse succeeded after repair", file=sys.stderr)
              except json.JSONDecodeError as repair_error:
                  print(f"✗ Entity JSON parse failed after repair: {repair_error}", file=sys.stderr)
                  print(f"Error at position: {repair_error.pos if hasattr(repair_error, 'pos') else 'unknown'}", file=sys.stderr)
                  print(f"Error message: {repair_error.msg}", file=sys.stderr)
                  print(f"Raw entity JSON (first 1000 chars): {entity_json_raw[:1000]}", file=sys.stderr)
                  print(f"Fixed entity JSON (first 1000 chars): {fixed_json[:1000]}", file=sys.stderr)
                  sys.exit(1)
          
          # Extract entity title
          entity_title = entity.get('title') or entity.get('identifier', '')
          print(f"Extracted entity title: {entity_title}", file=sys.stderr)
          
          # Use rule title if available, otherwise use identifier
          rule_display_name = rule_title if rule_title else rule_identifier
          print(f"Using rule display name: {rule_display_name}", file=sys.stderr)
          print(f"Rule description length: {len(rule_description)} characters", file=sys.stderr)
          print(f"Rule template length: {len(rule_template)} characters", file=sys.stderr)
          
          # Generate the template content by replacing placeholders
          result = rule_template.replace('{{ Rule }}', rule_display_name)
          result = result.replace('{{ s3 }}', entity_title)
          result = result.replace('{{ Description }}', rule_description)
          
          print("Generated template content:")
          print(result)
          print(f"Generated content length: {len(result)} characters", file=sys.stderr)
          
          # Set output for use in subsequent steps (using multiline output)
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("content<<EOF\n")
              f.write(result)
              f.write("\nEOF\n")
          
          sys.exit(0)
          PYEOF
      
      - name: Create scorecard task entity
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: create_task
        run: |
          # Get the team identifier from the extracted rule outputs
          # The team value might be an array, so we need to extract the first one if it's an array
          TEAM_VALUE="${{ steps.extract_rule.outputs.team }}"
          
          # Extract first team identifier if it's an array, otherwise use the value
          # Use Python to safely parse if it's JSON array or string
          TEAM_IDENTIFIER=$(python3 << 'PYEOF'
          import json
          import os
          import sys
          team_value = os.environ.get('TEAM_VALUE', '')
          if not team_value or team_value == "null":
              print("")
              sys.exit(0)
          try:
              # Try to parse as JSON (in case it's an array)
              parsed = json.loads(team_value)
              if isinstance(parsed, list) and len(parsed) > 0:
                  print(parsed[0])
              elif parsed:
                  print(parsed)
              else:
                  print("")
          except (json.JSONDecodeError, TypeError):
              # If not JSON, use as string
              print(team_value if team_value else "")
          PYEOF
          TEAM_VALUE="$TEAM_VALUE"
          )
          
          # Get the generated template content
          RESOLUTION_CONTENT="${{ steps.generate_template.outputs.content }}"
          
          # Generate a title for the task using Python to parse entity JSON
          eval $(python3 << 'PYEOF'
          import json
          import os
          import sys
          import re
          
          # Get values from GitHub Actions outputs
          rule_title = '''${{ steps.extract_rule.outputs.title }}'''
          rule_identifier = '''${{ steps.extract_rule.outputs.identifier }}'''
          entity_json_raw = '''${{ steps.get_entity.outputs.entity }}'''
          entity_id_input = '''${{ inputs.entity_id }}'''
          
          # Parse entity JSON (same repair logic)
          def repair_json(json_str):
              result = []
              i = 0
              in_string = False
              escape_next = False
              
              while i < len(json_str):
                  char = json_str[i]
                  
                  if escape_next:
                      result.append(char)
                      escape_next = False
                  elif char == '\\':
                      result.append(char)
                      escape_next = True
                  elif char == '"' and not escape_next:
                      in_string = not in_string
                      result.append(char)
                  elif in_string and char == '\n':
                      result.append('\\n')
                  elif in_string and char == '\r':
                      result.append('\\r')
                  elif in_string and char == '\t':
                      result.append('\\t')
                  else:
                      result.append(char)
                  
                  i += 1
              
              return ''.join(result)
          
          # Parse entity JSON
          print("Step: Create task - Starting entity JSON parsing", file=sys.stderr)
          print(f"Entity JSON length: {len(entity_json_raw)} characters", file=sys.stderr)
          entity_title = entity_id_input  # Default to input ID
          
          if entity_json_raw and entity_json_raw != "null":
              try:
                  print("Attempting initial entity JSON parse for task creation...", file=sys.stderr)
                  entity = json.loads(entity_json_raw)
                  entity_title = entity.get('title') or entity.get('identifier', entity_id_input)
                  print(f"✓ Entity JSON parse succeeded. Extracted title: {entity_title}", file=sys.stderr)
              except json.JSONDecodeError as initial_error:
                  print(f"✗ Initial entity JSON parse failed: {initial_error}", file=sys.stderr)
                  print(f"Error at position: {initial_error.pos if hasattr(initial_error, 'pos') else 'unknown'}", file=sys.stderr)
                  try:
                      print("Attempting entity JSON repair for task creation...", file=sys.stderr)
                      fixed_json = repair_json(entity_json_raw)
                      entity = json.loads(fixed_json)
                      entity_title = entity.get('title') or entity.get('identifier', entity_id_input)
                      print(f"✓ Entity JSON parse succeeded after repair. Extracted title: {entity_title}", file=sys.stderr)
                  except Exception as repair_error:
                      print(f"✗ Entity JSON parse failed after repair: {repair_error}", file=sys.stderr)
                      print(f"Falling back to entity_id_input: {entity_id_input}", file=sys.stderr)
                      entity_title = entity_id_input
          else:
              print(f"Entity JSON is empty or null, using entity_id_input: {entity_id_input}", file=sys.stderr)
          
          # Use rule title if available, otherwise use identifier
          rule_display = rule_title if rule_title else rule_identifier
          task_title = f"Task: {rule_display} - {entity_title}"
          
          # Output as shell variable assignments
          print(f"export TASK_TITLE='{task_title}'")
          print(f"export ENTITY_TITLE='{entity_title}'")
          PYEOF
          )
          
          # Use rule title if available, otherwise use identifier
          RULE_DISPLAY="${RULE_TITLE:-$RULE_IDENTIFIER}"
          
          # Prepare properties JSON
          PROPERTIES_JSON=$(jq -n \
            --arg resolution "$RESOLUTION_CONTENT" \
            '{resolution: $resolution}')
          
          # Prepare relations JSON - build object conditionally
          RELATIONS_JSON=$(jq -n \
            --arg rule_id "${{ inputs.rule_id }}" \
            --arg entity_id "${{ inputs.entity_id }}" \
            --arg team_id "$TEAM_IDENTIFIER" \
            '{
              rule: $rule_id,
              s_3: $entity_id
            } + (if $team_id != "" and $team_id != "null" then {team: $team_id} else {} end)')
          
          echo "Creating scorecard task entity:"
          echo "  Title: $TASK_TITLE"
          echo "  Rule: ${{ inputs.rule_id }}"
          echo "  Entity: ${{ inputs.entity_id }}"
          echo "  Team: $TEAM_IDENTIFIER"
          echo "  Properties: $PROPERTIES_JSON"
          echo "  Relations: $RELATIONS_JSON"
          
          # Set outputs using multiline format for JSON that may contain newlines
          echo "task_title=$TASK_TITLE" >> $GITHUB_OUTPUT
          
          # Use multiline format for properties JSON (it contains newlines in the resolution field)
          {
            echo "properties<<EOF"
            echo "$PROPERTIES_JSON"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          # Use multiline format for relations JSON as well (to be safe)
          {
            echo "relations<<EOF"
            echo "$RELATIONS_JSON"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      
      - name: Upsert scorecard task entity
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: upsert_task
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: UPSERT
          blueprint: scorecard_tasks
          title: ${{ steps.create_task.outputs.task_title }}
          properties: ${{ steps.create_task.outputs.properties }}
          relations: ${{ steps.create_task.outputs.relations }}
          runId: ${{ inputs.run_id }}
      
      - name: Log task creation success
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: "Successfully created scorecard task: ${{ steps.create_task.outputs.task_title }}"

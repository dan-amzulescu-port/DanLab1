name: Handle degraded rule result

on:
  workflow_dispatch:
    inputs:
      rule_result_id:
        description: "The rule result entity identifier"
        required: true
        type: string
      rule_id:
        description: "The rule entity identifier"
        required: true
        type: string
      entity_id:
        description: "The entity identifier that failed the rule"
        required: true
        type: string
      run_id:
        description: "Port action run ID"
        required: true
        type: string

jobs:
  print_inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Log message to Port run
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: "Starting scorecard failure handling for rule result: ${{ inputs.rule_result_id }}"
      
      - name: Get rule entity information
        id: get_rule
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: GET
          blueprint: "_rule"
          identifier: ${{ inputs.rule_id }}
      
      - name: Get entity information
        id: get_entity
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: GET
          blueprint: s3
          identifier: ${{ inputs.entity_id }}
      
      - name: Extract rule properties and validate
        id: extract_rule
        run: |
          # The Port GitHub Action outputs the entity as a JSON string with potential newlines
          # Use Python to repair and parse the JSON
          python3 << 'PYEOF'
          import json
          import os
          import sys
          import re
          
          # Get the raw JSON string from GitHub Actions output
          entity_json_raw = '''${{ steps.get_rule.outputs.entity }}'''
          
          if not entity_json_raw or entity_json_raw.strip() == "null":
              print("Error: Rule entity not found or empty", file=sys.stderr)
              sys.exit(1)
          
          # Repair JSON by escaping newlines and other control characters in string values
          # This regex finds string values (including nested ones) and escapes control chars
          def escape_control_chars(match):
              # Get the full match including quotes
              full_match = match.group(0)
              # Get the content between quotes
              content = match.group(1)
              # Escape control characters
              content = (content
                        .replace('\\', '\\\\')  # Escape backslashes first
                        .replace('\n', '\\n')
                        .replace('\r', '\\r')
                        .replace('\t', '\\t')
                        .replace('\b', '\\b')
                        .replace('\f', '\\f'))
              return f'"{content}"'
          
          # Pattern to match string values: "..." but not already escaped ones
          # This is tricky - we need to match strings but handle escaped quotes
          # Simple approach: replace newlines in the raw string before JSON parsing
          # But we need to be careful not to break the JSON structure
          
          # Better approach: use a state machine or use json.JSONDecoder with custom handling
          # For now, let's try a simpler fix: replace literal newlines that are inside string values
          # We'll use a more targeted approach
          
          try:
              # First, try to parse as-is
              entity = json.loads(entity_json_raw)
          except json.JSONDecodeError:
              # If that fails, try to fix newlines in string values
              # Find all string values and escape newlines in them
              fixed_json = entity_json_raw
              
              # Replace newlines that appear between quotes (string values)
              # This is a simplified approach - find patterns like "text\nmore text"
              # We'll use a regex that matches quoted strings and escapes newlines within them
              
              # More robust: iterate through and fix string values
              result = []
              i = 0
              in_string = False
              escape_next = False
              
              while i < len(entity_json_raw):
                  char = entity_json_raw[i]
                  
                  if escape_next:
                      result.append(char)
                      escape_next = False
                  elif char == '\\':
                      result.append(char)
                      escape_next = True
                  elif char == '"' and not escape_next:
                      in_string = not in_string
                      result.append(char)
                  elif in_string and char == '\n':
                      result.append('\\n')
                  elif in_string and char == '\r':
                      result.append('\\r')
                  elif in_string and char == '\t':
                      result.append('\\t')
                  else:
                      result.append(char)
                  
                  i += 1
              
              fixed_json = ''.join(result)
              
              try:
                  entity = json.loads(fixed_json)
              except json.JSONDecodeError as e:
                  print(f"Error: Invalid JSON from rule entity: {e}", file=sys.stderr)
                  print(f"JSON string (first 500 chars): {entity_json_raw[:500]}", file=sys.stderr)
                  sys.exit(1)
          
          # Extract properties
          properties = entity.get('properties', {})
          rule_description = properties.get('description', '')
          rule_template = properties.get('template', '')
          rule_team = entity.get('team', '')
          rule_title = entity.get('title') or entity.get('identifier', '')
          rule_identifier = entity.get('identifier', '')
          
          # Validate that description and template are not null/empty
          validation_failed = False
          error_message = ""
          
          if not rule_description or rule_description == "null":
              validation_failed = True
              error_message = f"Rule description is missing or null for rule: {rule_identifier}"
          elif not rule_template or rule_template == "null":
              validation_failed = True
              error_message = f"Rule template is missing or null for rule: {rule_identifier}"
          
          # Set GitHub Actions outputs
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"VALIDATION_FAILED={str(validation_failed).lower()}\n")
              if validation_failed:
                  f.write(f"ERROR_MESSAGE={error_message}\n")
              else:
                  # Use multiline format for values that might contain newlines
                  if '\n' in rule_description:
                      f.write(f"description<<EOF\n{rule_description}\nEOF\n")
                  else:
                      f.write(f"description={rule_description}\n")
                  
                  if '\n' in rule_template:
                      f.write(f"template<<EOF\n{rule_template}\nEOF\n")
                  else:
                      f.write(f"template={rule_template}\n")
                  
                  f.write(f"team={rule_team}\n")
                  f.write(f"title={rule_title}\n")
                  f.write(f"identifier={rule_identifier}\n")
          
          if not validation_failed:
              print(f"Rule Description: {rule_description}")
              print(f"Rule Template: {rule_template}")
              print(f"Rule Team: {rule_team}")
          
          sys.exit(0)
          PYEOF
      
      - name: Log validation error and exit
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'true'
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: ${{ steps.extract_rule.outputs.ERROR_MESSAGE }}
      
      - name: Fail if validation failed
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'true'
        run: |
          echo "Validation failed. Exiting workflow."
          exit 1
      
      - name: Generate template content
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: generate_template
        run: |
          # Get entity information
          ENTITY_JSON="${{ steps.get_entity.outputs.entity }}"
          TITLE=$(echo "$ENTITY_JSON" | jq -r '.title // .identifier // ""')
          
          # Get rule information
          RULE_TITLE="${{ steps.extract_rule.outputs.title }}"
          RULE_IDENTIFIER="${{ steps.extract_rule.outputs.identifier }}"
          RULE_DESCRIPTION="${{ steps.extract_rule.outputs.description }}"
          RULE_TEMPLATE="${{ steps.extract_rule.outputs.template }}"
          
          # Use rule title if available, otherwise use identifier
          RULE_DISPLAY_NAME="${RULE_TITLE:-$RULE_IDENTIFIER}"
          
          # Generate the template content by replacing placeholders using Python
          GENERATED_CONTENT=$(echo "$RULE_TEMPLATE" | RULE_NAME="$RULE_DISPLAY_NAME" ENTITY_NAME="$ENTITY_TITLE" DESCRIPTION="$RULE_DESCRIPTION" python3 << 'PYEOF'
          import os
          import sys
          template = sys.stdin.read()
          rule_name = os.environ.get('RULE_NAME', '')
          entity_name = os.environ.get('ENTITY_NAME', '')
          description = os.environ.get('DESCRIPTION', '')
          result = template.replace('{{ Rule }}', rule_name).replace('{{ s3 }}', entity_name).replace('{{ Description }}', description)
          print(result, end='')
          PYEOF
          )
          
          echo "Generated template content:"
          echo "$GENERATED_CONTENT"
          
          # Set output for use in subsequent steps (using multiline output)
          {
            echo "content<<EOF"
            echo "$GENERATED_CONTENT"
            echo "EOF"
          } >> $GITHUB_OUTPUT
      
      - name: Create scorecard task entity
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: create_task
        run: |
          # Get the team identifier from the extracted rule outputs
          # The team value might be an array, so we need to extract the first one if it's an array
          TEAM_VALUE="${{ steps.extract_rule.outputs.team }}"
          
          # Extract first team identifier if it's an array, otherwise use the value
          # Use Python to safely parse if it's JSON array or string
          TEAM_IDENTIFIER=$(python3 << 'PYEOF'
          import json
          import os
          import sys
          team_value = os.environ.get('TEAM_VALUE', '')
          if not team_value or team_value == "null":
              print("")
              sys.exit(0)
          try:
              # Try to parse as JSON (in case it's an array)
              parsed = json.loads(team_value)
              if isinstance(parsed, list) and len(parsed) > 0:
                  print(parsed[0])
              elif parsed:
                  print(parsed)
              else:
                  print("")
          except (json.JSONDecodeError, TypeError):
              # If not JSON, use as string
              print(team_value if team_value else "")
          PYEOF
          TEAM_VALUE="$TEAM_VALUE"
          )
          
          # Get the generated template content
          RESOLUTION_CONTENT="${{ steps.generate_template.outputs.content }}"
          
          # Generate a title for the task
          RULE_TITLE="${{ steps.extract_rule.outputs.title }}"
          RULE_IDENTIFIER="${{ steps.extract_rule.outputs.identifier }}"
          ENTITY_JSON="${{ steps.get_entity.outputs.entity }}"
          ENTITY_TITLE=$(echo "$ENTITY_JSON" | jq -r '.title // .identifier // ""')
          
          # Use rule title if available, otherwise use identifier
          RULE_DISPLAY="${RULE_TITLE:-$RULE_IDENTIFIER}"
          ENTITY_DISPLAY="${ENTITY_TITLE:-${{ inputs.sentity_id }}}"
          TASK_TITLE="Task: $RULE_DISPLAY - $ENITY_DISPLAY"
          
          # Prepare properties JSON
          PROPERTIES_JSON=$(jq -n \
            --arg resolution "$RESOLUTION_CONTENT" \
            '{resolution: $resolution}')
          
          # Prepare relations JSON - build object conditionally
          RELATIONS_JSON=$(jq -n \
            --arg rule_id "${{ inputs.rule_id }}" \
            --arg entity_id "${{ inputs.entity_id }}" \
            --arg team_id "$TEAM_IDENTIFIER" \
            '{
              rule: $rule_id,
              s_3: $entity_id
            } + (if $team_id != "" and $team_id != "null" then {team: $team_id} else {} end)')
          
          echo "Creating scorecard task entity:"
          echo "  Title: $TASK_TITLE"
          echo "  Rule: ${{ inputs.rule_id }}"
          echo "  Entity: ${{ inputs.entity_id }}"
          echo "  Team: $TEAM_IDENTIFIER"
          echo "  Properties: $PROPERTIES_JSON"
          echo "  Relations: $RELATIONS_JSON"
          
          # Set outputs
          echo "task_title=$TASK_TITLE" >> $GITHUB_OUTPUT
          echo "properties=$PROPERTIES_JSON" >> $GITHUB_OUTPUT
          echo "relations=$RELATIONS_JSON" >> $GITHUB_OUTPUT
      
      - name: Upsert scorecard task entity
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        id: upsert_task
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: UPSERT
          blueprint: scorecard_tasks
          title: ${{ steps.create_task.outputs.task_title }}
          properties: ${{ steps.create_task.outputs.properties }}
          relations: ${{ steps.create_task.outputs.relations }}
          runId: ${{ inputs.run_id }}
      
      - name: Log task creation success
        if: steps.extract_rule.outputs.VALIDATION_FAILED == 'false'
        uses: port-labs/port-github-action@v1
        with:
          clientId: ${{ secrets.PORT_CLIENT_ID }}
          clientSecret: ${{ secrets.PORT_CLIENT_SECRET }}
          baseUrl: https://api.us.getport.io
          operation: PATCH_RUN
          runId: ${{ inputs.run_id }}
          logMessage: "Successfully created scorecard task: ${{ steps.create_task.outputs.task_title }}"
